#=========================

1. MODULE 1

Introduction to Version Control

#=========================

Objectifs d'apprentissage

- Describe the concept of version control and why it is important to use
- Utilize the diff and patch commands to automate differentiating and editing files
- Explain what Git is and its benefits of use
- Install Git on local machine
- Utilize Git to create and clone repositories, add code, check the status of code, and commit code

This course introduces Git, a popular version control system (VCS), and its benefits for managing code and configuration files.


1.1. Before Vesion Control

1.1.1. Version Control

Why is version control important?
- Track changes to code/files over time.
- Easily revert to previous versions if something breaks.
- Collaborate effectively with others on projects.

Why is Git useful?
- Widely used in IT and software development.
- Helps create a portfolio of projects for job interviews.
- Enables efficient teamwork and emergency recovery.

What will you learn in this course?
- Git's core functionality and its usage in organizations.
- Basic and advanced features like branching and merging.
- Using Git with remote repositories like GitHub.
- ÒPractical exercises to apply your learning.

Prerequisites:
- Git installed on your computer (instructions provided).
- Basic knowledge of Python (recommended but not mandatory).
- Python 3 installed (required for running scripts).
- Familiarity with the Linux command line (helpful but not essential).

Remember:
- Complex topics require revisiting and practice.
- Discussion forums are available for questions and support.



1.1.2. Diffing files (Before Version Control)

How would you do it? You could open both files in the editor side by side, look at one then look at the other to spot the differences, but that's super error-prone. 
We're human and by comparing with our eyes we are bound to miss some differences. 
Fortunately, there's a better way. You can use some nifty tools that will do this automatically. 
We can use the diff command line tool to take two files or even two directories, and show the differences between them in a few formats. 
Let's check it out with an example.

cat rearrange1.py 

Code output:
#!/usr/bin/env python3
import re
def rearrange_name(name):
    result = re.search(r"^([\w .]*), ([\w .]*)$", name)
    if result == None:
        return name
    return "{} {}".format(result[2], result[1])
user@ubuntu:~$ cat rearrange2.py 
#!/usr/bin/env python3
import re
def rearrange_name(name):
    result = re.search(r"^([\w .-]*), ([\w .-]*)$", name)
    if result == None:
        return name

    return "{} {}".format(result[2], result[1])

cat rearrange2.py 


Code output:
#!/usr/bin/env python3
import re
def rearrange_name(name):
    result = re.search(r"^([\w .-]*), ([\w .-]*)$", name)
    if result == None:
        return name
    return "{} {}".format(result[2], result[1])

diff rearrange1.py rearrange2.py 

Code output:
6c6
<     result = re.search(r"^([\w .]*), ([\w .]*)$", name)
---
>     result = re.search(r"^([\w .-]*), ([\w .-]*)$", name)

diff validations1.py validations2.py 

Code output:
5c5,6
<	assert (type(username) == str), "username must be a string"
--
>	if type(username != str: 
> 	    raise TypeError("username must be a string"
11a13,15
>	    return False
>	# Usernames can't begin with a number
>	if username[0].isnumeric():

Note: 6c6 c for change
11a13,15 a for added lines

diff -u validations1.py validations2.py 

Code output:
--- validations1.py	2019-06-06 14:28:49.639209499 +0200
+++ validations2.py	2019-06-06 14:30:48.019360890 +0200
@@ -2,7 +2,8 @@
 
  def validate_user(username, minlen):
-    assert type(username) == str, "username must be a string"
+    if type(username) != str:
+        raise TypeError("username must be a string")
     if minlen < 1:
         raise ValueError("minlen must be at least 1")
     
@@ -10,5 +11,8 @@
         return False
     if not username.isalnum():
         return False
+    # Usernames can't begin with a number
+    if username[0].isnumeric():
+        return False
     return True


1.1.3. Applying Changes

cat cpu_usage.py 

cat cpu_usage.py 
Code output:
#!/usr/bin/env python3
import psutil
def check_cpu_usage(percent):
    usage = psutil.cpu_percent()
    return usage < percent
if not check_cpu_usage(75):
    print("ERROR! CPU is overloaded")
else:

    print("Everything ok")

# Our colleague has generated a diff file with the following command

diff -u validations1.py validations2.py > cpu_usage.diff 

Note: diff -u old_file new_file > change.diff

# We have a look to the diff file before integrating it:

cat cpu_usage.diff 

Code output:
--- cpu_usage.py	2019-06-23 08:16:04.666457429 -0700
+++ cpu_usage_fixed.py	2019-06-23 08:15:37.534370071 -0700
@@ -2,7 +2,8 @@
 import psutil
 
 def check_cpu_usage(percent):
-    usage = psutil.cpu_percent()
+    usage = psutil.cpu_percent(1)
+    print("DEBUG: usage: {}".format(usage))
     return usage < percent
 
 if not check_cpu_usage(75):

# We apply the diff file to 

patch cpu_usage.py < cpu_usage.diff 

Code output:
patching file cpu_usage.py

cat cpu_usage.py 

Code output:
#!/usr/bin/env python3
import psutil
def check_cpu_usage(percent):
    usage = psutil.cpu_percent(1)
    print("DEBUG: usage: {}".format(usage))
    return usage < percent
if not check_cpu_usage(75):
    print("ERROR! CPU is overloaded")
else:

    print("Everything ok")


1.1.4. Practical Application of diff and patch

cp disk_usage.py disk_usage_original.py 
cp disk_usage.py disk_usage_fixed.py 


File with code

#!/usr/bin/env python3

import shutil

def check_disk_usage(disk, min_absolute, min_percent):
    """Returns True if there is enough free disk space, false otherwise."""
    du = shutil.disk_usage(disk)
    # Calculate the percentage of free space
    percent_free = 100 * du.free / du.total
    # Calculate how many free gigabytes
    gigabytes_free = du.free / 2**30
    if percent_free < min_percent or gigabytes_free < min_absolute:
        return False
    return True

# Check for at least 2 GB and 10% free
if not check_disk_usage("/", 2*2**30, 10):
    print("ERROR: Not enough disk space")
    return 1

print("Everything ok")
return 0


./disk_usage_fixed.py 

#this throws an error

Code output:
File "./disk_usage_fixed.py", line 19
    return 1
    ^
SyntaxError: 'return' outside function
File with code
The instructor adds import sys at the beginning, then change return 1 to sys.exit(1) and return 0 to sys.exit(0).

#!/usr/bin/env python3

import shutil
import sys

def check_disk_usage(disk, min_absolute, min_percent):
    """Returns True if there is enough free disk space, false otherwise."""
    du = shutil.disk_usage(disk)
    # Calculate the percentage of free space
    percent_free = 100 * du.free / du.total
    # Calculate how many free gigabytes
    gigabytes_free = du.free / 2**30
    if percent_free < min_percent or gigabytes_free < min_absolute:
        return False
    return True

# Check for at least 2 GB and 10% free
if not check_disk_usage("/", 2*2**30, 10):
    print("ERROR: Not enough disk space")
    sys.exit(1)

print("Everything ok")
sys.exit(0)

./disk_usage_fixed.py

Code output:
ERROR: Not enough disk space
File with code
Instructor changed change check_disk_usage("/", 2*2**30, 10) in previous file to check_disk_usage("/", 2, 10).

#!/usr/bin/env python3

import shutil
import sys

def check_disk_usage(disk, min_absolute, min_percent):
    """Returns True if there is enough free disk space, false otherwise."""
    du = shutil.disk_usage(disk)
    # Calculate the percentage of free space
    percent_free = 100 * du.free / du.total
    # Calculate how many free gigabytes
    gigabytes_free = du.free / 2**30
    if percent_free < min_percent or gigabytes_free < min_absolute:
        return False
    return True

# Check for at least 2 GB and 10% free
if not check_disk_usage("/", 2, 10):
    print("ERROR: Not enough disk space")
    sys.exit(1)

print("Everything ok")
sys.exit(0)

./disk_usage_fixed.py 

Code output:

Everything ok

diff -u disk_usage_original.py disk_usage_fixed.py > disk_usage.diff
cat disk_usage.diff 

Code output:
--- disk_usage_original.py	2019-06-22 15:13:38.591579963 -0700
+++ disk_usage_fixed.py	2019-06-22 15:41:35.013023839 -0700
@@ -1,6 +1,7 @@
 #!/usr/bin/env python3
 
 import shutil
+import sys
 
 def check_disk_usage(disk, min_absolute, min_percent):
     """Returns True if there is enough free disk space, false otherwise."""
@@ -14,9 +15,9 @@
     return True
 
 # Check for at least 2 GB and 10% free
-if not check_disk_usage("/", 2*2**30, 10):
+if not check_disk_usage("/", 2, 10):
     print("ERROR: Not enough disk space")
-    return 1
+    sys.exit(1)
 
 print("Everything ok")
-return 0
+sys.exit(0)

patch disk_usage.py < disk_usage.diff 
patching file disk_usage.py

Code output:
patching file disk_usage.py

./disk_usage.py 

Code output:

Everything ok


1.1.5. Quiz

Question 1
Your colleague sent you a patch called fix_names.patch, which fixes a config file called fix_names.conf. What command do you need to run to apply the patch to the config file?
- patch fix_names.conf < fix_names.patch
Correct
Nice job! The patch command with the file to be patched, followed by the filename of the patch, will apply it.

Question 2
You're helping a friend with a bug in a script called fix_permissions.py, which fixes the permissions of a bunch of files. 
To work on the file, you make a copy and call it fix_permissions_modified.py. 
What command do you need to run after solving the bug to send the patch to your friend?
diff fix_permissions.py fix_permissions_modified.py > fix_permissions.patch
Correct
Awesome! The diff command will allow us to compare and apply the differences between the files.

Question 3
The _____ commandhighlights the words that changed in a file instead of working line by line.
wdiff
Correct
Right on! The wdiff command highlights the words that changed in a file by color, in addition to working line by line.

Question 4
How can we choose the return value our script returns when it finishes?
Using the exit command from the sys module
Correct
Great work! A script can use sys.exit to finish processing and return the number passed as an argument as the script's return code.

Question 5
In addition to the original files, what else do we need before we can use the patch command?
Diff file
Correct
Woohoo! We need to use the patch command with the diff file to apply new changes to the original file.



1.1.6. diff and patch (study guide)


The diff command
You use the diff command to find the differences between two files. 
On its own, it’s a bit hard to use; instead, use diff -u to find lines that differ in two files:

Using diff -u
You use the diff -u command to compare two files, line by line, and have the differing lines compared side-by-side in the same output. 
For an example of what this looks like, see below:

~$ cat menu1.txt 
Menu1:

Apples
Bananas
Oranges
Pears

~$ cat menu2.txt 
Menu:

Apples
Bananas
Grapes
Strawberries

~$ diff -u menu1.txt menu2.txt 
--- menu1.txt   2019-12-16 18:46:13.794879924 +0900
+++ menu2.txt   2019-12-16 18:46:42.090995670 +0900
@@ -1,6 +1,6 @@
-Menu1:
+Menu:
 
 Apples
 Bananas
-Oranges
-Pears
+Grapes
+Strawberries


The patch command
The patch command is useful for applying file differences. See the example below, which compares two files. The comparison is saved as a .diff file, which is then patched to the original file!

~$ cat hello_world.txt 
Hello World
~$ cat hello_world_long.txt 
Hello World

It's a wonderful day!
~$ diff -u hello_world.txt hello_world_long.txt 
--- hello_world.txt     2019-12-16 19:24:12.556102821 +0900
+++ hello_world_long.txt        2019-12-16 19:24:38.944207773 +0900
@@ -1 +1,3 @@
 Hello World
+
+It's a wonderful day!
~$ diff -u hello_world.txt hello_world_long.txt > hello_world.diff
~$ patch hello_world.txt < hello_world.diff 
patching file hello_world.txt
~$ cat hello_world.txt 
Hello World

It's a wonderful day!



Resources for more information
There are other interesting patch and diff commands such as patch -p1 and diff -r . For more information on these commands, check out the following resources:
	•	http://man7.org/linux/man-pages/man1/diff.1.html
	•	http://man7.org/linux/man-pages/man1/patch.1.html


1.2. Version Control Systems

1.2.1. What is version control ?


Most of the time we won’t use dff command directly. Instead, we will use them through a Version Control System or VCS.

What is a VCS?
	•	Tracks changes made to files, including who made them and when.
	•	Allows reverting to previous versions if needed.
	•	Facilitates collaboration by merging changes from different sources.
	•	Stores all versions of a file, not just the latest.

Why use a VCS?
	•	Understand history of changes and identify responsible individuals.
	•	Easily rollback bad changes.
	•	Merge changes from multiple contributors effectively.
	•	Record reasons for changes for future reference (commits).
	•	Manage access control for different repositories.
	•	Track more than just code (e.g., configuration files, documents).
	•	Efficiently compare and modify text files using diff and patch tools.

Do I need a VCS?
While manual backups are helpful, VCS offers:
	•	More complete history and easier version selection.
	•	Collaboration features for teamwork.
	•	Improved organization and access control.

Next steps:
	•	Explore advantages of VCS over manual backups in more detail.



1.2.2. Version Control and Automation


Benefits of a VCS for one person:
	•	Version history and snapshots: Track past changes and easily revert if needed.
	•	Documentation through commit messages: Explain decisions and avoid future confusion.
	•	Improved system reliability: Quickly recover from errors and maintain accurate records.
	•	Scalability and automation: Manage configuration files for multiple systems and automate deployments.

Examples:
	•	DNS zone file: Track changes, revert if errors occur, and know which version to restore.
	•	DHCP server configuration: Ensure all machines have identical files for smooth failover.
	•	Automatic server deployment: Simplify and streamline the process with VCS-stored configuration.

Overall, a VCS can save time, improve organization, and enhance the reliability of your IT systems, even if you work alone.



1.2.3. What is Git ?


Summary of Git: A Distributed Version Control System
This text introduces Git, a popular VCS created by Linus Torvalds for managing the Linux kernel project.

Key features of Git:
	•	Open source and free: Available for various platforms (Unix, Windows, macOS).
	•	Distributed architecture: Each contributor has a complete copy of the repository.
	•	Offline functionality: Works without a network connection.
	•	Scalability: Handles projects with one or thousands of contributors.
	•	Flexibility: Tracks private work or code shared publicly on platforms like GitHub.

Additional details:
	•	Git clients communicate with servers using various protocols (HTTP, SSH, etc.).
	•	Git-scm.com is the official Git website, and "SCM" stands for Source Control Management.
	•	While Git is preferred for this course, alternative VCS tools like Subversion or Mercurial exist.

Next steps:
	•	Take a quiz to solidify understanding before learning how to use Git.

Git is a distributed plateforme: which means that each developer has a full copy of the repository.
Unlike some version control systems that are centralized around a single server, Git has a distributed architecture.
This means that every person contributing to a repository has a full copy of the repository on their own development machines.
Collaborators can share and pull in changes that others have made as they need. 
And because the repositories are all local to the computer being used to create the files, most operations can be done really fast. 
If you want to collaborate with others, it usually makes sense to set up a repository on a server to act as a kind of hub for everyone to interact with.



Quiz: Version Control Systems

How can a VCS (Version Control System) come in handy when updating your software, even if you’re a solo programmer?
- If something breaks due to a change, you can fix the problem by reverting to a working version before the change.
- Git allows you to review the history of your project.

Who is the original creator and main developer of the VCS (Version Control System) tool Git?
- Linus Torvalds

_____ is a feature of a software management system that records changes to a file or set of files over time so that you can recall specific versions later.
- Version Control

A _____ is a collection of edits which has been submitted to the version control system for safe keeping.
Commit

Within a VCS, project files are organized in centralized locations called _____ where they can be called upon later.
Repositories


More Information About Git
	•	https://git-scm.com/doc
	•	https://www.mercurial-scm.org/
	•	https://subversion.apache.org/
	•	https://en.wikipedia.org/wiki/Version_control

Note: SCM stands for Source Control Management

1.2.4. Installing Git

The first step on the way to using Git is to install it!  But before it you have to check whether you already have it installed with the command:

git —version

If not installed, the directions found in the Git documentation below are pretty thorough and helpful. 
Check them out for the best method of installing Git onto your platform of choice.
You can go directly to 
Git - Downloads
 to download Git. This page does not provide detailed instructions for installing Git, but it does have links to download Git for the Linux, macOS, and Windows platforms. 
For step-by-step instructions on how to install Git, go to the 
Getting Started - Installing Git
 page. This page provides detailed instructions for installing Git on Linux, macOS, Windows, or from Source. Follow the directions provided for your platform of choice. 

Install git on Linux:
$ sudo apt udpate
$ sudo apt install git


1.3. Using Git

1.3.1. First steps with Git
 
We need to tell Git who we are. We can do this by using Git config command and then setting the values of user.email and user.name:
git config --global user.email "me@example.com"
git config --global user.name "My name"


We create a check directory

mkdir checks
cd checks

For now, let's start by creating a new directory and then a git repository inside that directory. 
So when we run git init we initialize an empty git repository in the current directory. 
The message that we get mentions a directory called. git.

git init


Code output:
Initialized empty Git repository in /home/user/checks/.git/
We can check that this directory exists using the ls-la command which lists files that start with a dot. 

ls -la


Code output:
total 12
drwxrwxr-x  3 user user 4096 Jul  9 18:16 .
drwxr-xr-x 18 user user 4096 Jul  9 18:16 ..
drwxrwxr-x  7 user user 4096 Jul  9 18:16 .git


We can also use the ls-l.git command to look inside of it and see the many different things it contains.

ls -l .git/


Code output:
total 32
drwxrwxr-x 2 user user 4096 Jul  9 18:16 branches
-rw-rw-r-- 1 user user   92 Jul  9 18:16 config
-rw-rw-r-- 1 user user   73 Jul  9 18:16 description
-rw-rw-r-- 1 user user   23 Jul  9 18:16 HEAD
drwxrwxr-x 2 user user 4096 Jul  9 18:16 hooks
drwxrwxr-x 2 user user 4096 Jul  9 18:16 info
drwxrwxr-x 4 user user 4096 Jul  9 18:16 objects
drwxrwxr-x 4 user user 4096 Jul  9 18:16 refs


This is called a Git directory. 
You can think of it as a database for your Git project that stores the changes and the change history. 
We can see it contains a bunch of different files and directories. 
We won't touch any of these files directly, we'll always interact with them through Git commands. 
So whenever you clone a repository, this git directory is copied to your computer. 
Whenever you run git init to create a new repository like we just did, a new git directory is initialized.


The area outside the git directory is the working tree. 
The working tree is the current version of your project. 
You can think of it like a workbench or a sandbox where you perform all the modifications you want to your file. 
This working tree will contain all the files that are currently tracked by Git and any new files that we haven't yet added to the list of track files. 

The git directory contains all the changes and their history and the working tree contains the current versions of the files.



Right now our working tree is empty. 
Let's change that by copying the disk usage that py file that we saw in an earlier video into our current directory.


cp ../disk_usage.py .
ls -l


Code output:
total 4
-rw-rw-r-- 1 user user 657 Jul  9 18:26 disk_usage.py

We now have a file and a working tree but it's currently untracked by Git. 
To make Git track our file, we'll add it to the project using the git add command passing the file that we want as a parameter. 

git add disk_usage.py 

With that, we've added our file to the staging area. 
The staging area which is also known as the index is a file maintained by Git that contains 
all of the information about what files and changes are going to go into your next commit.

We can use the git status command to get some information about the current working tree and pending changes. 
Let's check that one out. 



git status

Code output:
On branch master
No commits yet
Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
	new file:   disk_usage.py


We see that our new file is marked to be committed, this means that our change is currently in the staging area. 
To get it committed into the.git directory, we run the git commit command. Let's try that now.


git commit


When we run this command, we tell Git that we want to save our changes. It opens a text editor where we can enter a commit message. 
If you want, you can change the editor used to your preferred editor. In our case, this computer has nano configured as a default editor.
The texts that we get tells us that we need to write a commit message and that the change to be committed is the new file that we've added.
We'll deep dive into commit messages later. 
For now, let's enter a simple description of what we did which was to add this one file and then exit the editor saving our commit message.


Code output:
 GNU nano 3.2         /home/user/checks/.git/COMMIT_EDITMSG                    
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
#
# On branch master
#
# Initial commit
#
# Changes to be committed:
#       new file:   disk_usage.py


And with that we've created our first git commit. 
Up next, we'll talk more about the life cycle of each track file in a git repository.

1.3.2. Tracking Files


In our last video, we mentioned that any Git project will consist of three sections. 
The Git directory, the working tree, and the staging area. 
The Git directory contains the history of all the files and changes. 
The working tree contains the current state of the project, including any changes that we've made. 
And the staging area contains the changes that have been marked to be included in the next commit. 



This can still be confusing. So it might be helpful to think about Git as representing your project. 
Which is the code and associated files and a series of snapshots. 
Each time you make a commit, Git records a new snapshot of the state of your project at that moment. 



It's a picture of exactly how all these files looked at a certain moment in time. 



Combined, these snapshots make up the history of your project, and it's information that gets stored in the Git directory.



Now, let's dive into the details of how we track changes to our files. 

When we operate with Git, our files can be either tracked or untracked. 

Tracked files are part of the snapshots, while untracked files aren't a part of snapshots yet. 

This is the usual case for new files. Each track file can be in one of three main states, modified, staged or committed. 
Let's look at what each of these mean.

If a file is in the modified state, it means that we've made changes to it that we haven't committed yet. 
The changes could be adding, modifying or deleting the contents of the file. 
Git notices anytime we modify our files. But won't store any changes until we add them to the staging area.

So, the next step is to stage those changes.

When we do this, our modified files become stage files. In other words, the changes to those files are ready to be committed to the project. 
All files that are staged will be part of the next snapshot we take. 
And finally, when a file gets committed, the changes made to it are safely stored in a snapshot in the Git directory.

This means that typically a file tracked by Git, will first be modified when we change it in any way. 
Then it becomes staged when we mark those changes for tracking. 
And finally it will get committed when we store those changes in the VCS. Let's see this in action in our example Git repo. 


First, let's check the contents of the current working tree using ls-l. 

cd checks
ls -l

Code output:
total 4
-rw-r--r-- 1 user user 657 Jul  9 12:52 disk_usage.py
user@ubuntu:~/checks$ git status
On branch master
nothing to commit, working tree clean


And then the current status of our files using the Git status command.

git status

Code output:
On branch master
nothing to commit, working on clean tree

When we run Git status, Git tells us a bunch of things, including that we're on the master branch. 
For now, notice how it says that there's nothing to commit and that the working tree is clean. 
Let's modify a file to change that.

For example, we'll just add periods at the end of the message that our script presents to the user.

atom disk_usage.py 




So, now that we've made the change, let's call Git status again and see the new output.


git status

Code output:
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	modified:   disk_usage.py



Again, Git tells us a lot of things, including giving us some tips for commands that we might want to use. 
These tips can come in real handy, especially when we're familiarizing ourselves with Git. 
See how the file we changed is now marked as modified? And that it's currently not staged for commit?

Let's change that by running the Git add command, passing the disk usage py file as a parameter.

git add disk_usage.py


git status


Code output:
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	modified:   disk_usage.py


When we call Git add, we're telling Git that we want to add the current changes in that file to the list of changes to be committed. 
This means that our file is currently part of the staging area, and it will be committed once we run the next Git command, Git commit. 
In this case, instead of opening up an editor, let's pass the commit message using the dash m flag, stating that we added periods at the end of the sentences.

git commit -m 'Add periods to the end of sentences.'


Code output:
[master ae8d19c] Add periods to the end of sentences.
 1 file changed, 2 insertions(+), 2 deletions(-)


So, we've now committed our stage changes.
This creates a new snapshot in the Git directory.
The command shows us some stats for the change made. Let's do one last status check.

git status


Code output:
On branch master
nothing to commit, working tree clean

We see that once again, we have no changes to commit. 
Because the change we made has gone through the full cycle of modified, staged and committed. 
So to sum up, we work on modified files in our working tree. When they're ready, we staged these files by adding them to the staging area. 
Finally, we commit the changes sitting in our staging area, which takes a snapshot of those files and stores them in the database that lives in the Git directory. 
If the way Git works is not totally clear yet, don't worry. It will all sink in with a bit more practice.
In our next video, we'll put this all together and go over the typical workflow when working with Git.


1.3.3. The Basic Git Workflow


In earlier videos, we discussed some of the basic concepts involved in working with Git. 
We saw that each repository will have a Git directory, a working tree, and a staging area. 
And we called out that files can be in three different states, modified, staged, and committed. 
Let's review these concepts one more time by looking at the normal workflow when operating with Git on a day to day basis. 
First, all the files we want to manage with Git must be a part of a Git repository. 
We initialize a new repository by running the git init command in any file system directory. 
For example, let's use the mkdir command to create a directory called scripts, and then change into it and initialize an empty Git repository init.


mkdir scripts
cd scripts
git init

Code output:
Initialized empty Git repository in /home/user/scripts/.git/

Our shiny new Git repository can now be used to track changes to files inside of it. 
But before jumping into that, let's check out our current configuration by using the git config -l command.

git config -l

Code output:
user.email=me@example.com
user.name=My name
core.repositoryformatversion=0
core.filemode=true
core.bare=false
core.logallrefupdates=true


There's a bunch of info in there, and we won't cover all of it. 
For now, pay special attention to the user.email and the user.name lines, which we touched on briefly in an earlier video. 
This information will appear in public commit logs if you use a shared repository. 
For privacy reasons, you might want to use different identities when dealing with your private work and when submitting code to public repositories. 
We'll include more details about changing this information in our next reading. 
Okay, our repo is ready to work, but it's currently empty. 
Let's create a file in it, we'll start with a basic skeleton for a Python script, which will help us demonstrate the Git workflow. 
As with any Python script, we'll start with the shebang line. 
For now, we'll add an empty main function, which we'll fill in later. 
And at the end, we'll just call this main function.


File with code

#!/usr/bin/env python3

def main():
    pass

main()


All right, we've created our file. This is a script that we'll want to execute, so let's make it executable. 
And then let's check the status of our repo using git status command.

chmod +x all_checks.py
git status

Code output:
On branch master
No commits yet
Untracked files:
  (use "git add <file>..." to include in what will be committed)
	all_checks.py
nothing added to commit but untracked files present (use "git add" to track)


As we called out before, when we create a new file in a repository, it starts off as untracked. 
We can make all kinds of changes to the file, but until we tell Git to track it, Git won't do anything with an untracked file. 
Do you remember what command we have to use to make Git track our file? That's right, we need to call the git add command.

git add all_checks.py

This command will immediately move a new file from untracked to stage status. 
And as we'll see later, it will also change a file in the modified state to staged state. 
Remember that when a file is staged, it means it's been added to the staging area and it's ready to be committed to the Git repository. 
To initiate a commit of staged files, we issue the git commit command. 
When we do this, Git will only commit the changes that have been added to the staging area, untracked files or modified files that weren't staged will be ignored. Calling git commit with no parameters will launch a text editor, this will open whatever has been set as your default editor.

If the default editor is not the one you'd like to use, there are a bunch of ways to change it. 
We'll include more info about changing the default editor in the next reading. 
For now, let's edit our message with Nano, which is the current default for this computer.

git commit

File with code

Create an empty all_checks.
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
#
# On branch master
#
# Initial commit
#
# Changes to be committed:
#       new file:   all_checks.py
#

We'll say that our change is creating an empty all_checks.py file, then save and exit. 
Voila! We've just recorded a snapshot of the code in our project, which is stored in the Git directory. 
Remember that every time we commit changes, we take another snapshot, which is annotated with a commit message that we can review later.

Okay, that's how we add new files, but usually we'll modify existing ones. 
So let's add a bit more content to our script to see that in action. 
We'll add a function called check_reboot, that will check if the computer is pending a reboot. 
To do that, we'll check if the run/reboot-required file exists.

File with code

#!/usr/bin/env python3

import os

def check_reboot():
    """Returns True if the computer has a pending reboot."""
    return os.path.exists("/run/reboot-required")   

def main():
    pass

main()


This is a file that's created on our computer when some software requires a reboot. 
And of course, since we're using os.path.exists, we need to add import os to our script.

All right, we've added a function to our file. Let's check the current status using git status again.

git status

On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)
	modified:   all_checks.py
no changes added to commit (use "git add" and/or "git commit -a")


Our file's modified, but not staged. To stage our changes, we need to call git add once again.

git add all_checks.py 

git status

Code output:
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)
	modified:   all_checks.py


Okay, our changes are now staged. What do we need to do next? You got it, we have to call git commit to store those changes to the Git directory. 
This time, we'll use the other way of setting the commit message. We'll call git commit -m, and then pass the commit message that we want to use. 
So in this case, we'll say that we've added the check_reboot function.

git commit -m 'Add a check_reboot function'

Code output:
[master d8e139c] Add a check_reboot function
 1 file changed, 6 insertions(+)

With that, we've demonstrated the basic Git workflow. We make changes to our files, stage them with git add, and commit them with git commit. Are you starting to feel more comfortable with this process, and see how it fits within the rest of your tasks?

If there's anything that's not totally clear yet, remember, that the only way to get familiar with these concepts is practice.

Feel free to try these examples out on your computer as we go along, until you get comfortable with these commands.

Up next we'll talk more about how to write useful commit messages.


1.3.4. Anatomy of a commit message

In earlier videos, we saw how we can commit snapshots of changes to the Git repository. 
Let's now talk a little bit more about what makes a good commit message. 
Writing a clear informative commit message is important when you use a VCS, future you or other developers or IT specialists who might read the commit message later on will really appreciate the contextual information as they try and figure out some of the parts of the code or configuration. 
So what makes a good commit message? It can be helpful to keep your audience in mind when you write commit messages. 
What would someone reading a message weeks or months from now want to know about the changes you've made? 
What might be especially important or tricky to understand about them? Is there extra information that might help the reader out, like links to design documents or tickets in your ticketing system? 
Similarly to how style guides exist for writing code, your company might have specific rules for you to follow when you write commit messages. 
Even if they don't, it's good to use a few general guidelines to make sure your commit messages are as clear and useful as possible. 

A commit message is generally broken up into a few sections. 
The first line is a short summary of the commit followed by a blank line. 
This is followed by a full description of the changes which details why they're necessary and anything that might be especially interesting about them or difficult to understand. 

When you run the git commit command, Git will open up a text editor of your choice so you can write your commit message. 
A good commit message might look something like this.

cat example_commit.txt 


Code output:

Provide a good commit message example

The purpose of this commit is to provide an example of a hand-crafted,
artisanal commit message. The first line is a short, approximately 50-character
summary, followed by an empty line. The subsequent paragraphs are jam-packed
with descriptive information about the change, but each line is kept under 72
characters in length.
If even more information is needed to explain the change, more paragraphs can
be added after blank lines, with links to issues, tickets, or bugs. Remember
that future you will thank current you for your thoughtfulness and foresight!
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
#
# On branch master
#
# Changes to be committed:
# new file:   super_script.py
# new file:   cool_config.txt



So the first line Provide a good commit message example is usually kept to about 50 characters or less. 
The line contains a short description of what the commit changes are about. 
After the first line, comes an empty line, and the rest of the text is usually kept under 72 characters. 
This text is intended to provide a detailed explanation of what's going on with the change. 
It can reference bugs or issues that will be fixed with the change. It can also include links to more information when relevant. 
The line limits can be annoying but they help in making the commit message be more digestible for the reader. 
There's a git command used to display these commit messages called git log. This command will do any line wrapping for us. 
Which means that if we don't stick to the recommended line wrapping, long commit messages will run off the edge of the screen and be difficult to read. 

Now, take a look at the lines in the commit message that start with the pound symbol. 
Just like in Python, this symbol indicates that these lines are comments and won't get included in the commit message. 
Git shows them to us whenever we're writing a commit message as a reminder of what files were about to commit. 
Sometimes it can be tempting to just write something short like update, change or fix as the description of our commit messages. Don't do it. 
It's super frustrating to go back to repository’s history and discover that there's not enough context to understand what was changed and why. 
It takes only a few more seconds to write a better description. This can be invaluable down the line. 

Following these guidelines can help make your commit message really useful, and the investment of work now will really pay off later. 
If you're interested in learning more about git commit style, there are plenty of resources out there to read including the Linux kernel documentation itself along with impassioned opinions from other developers.

We said that we can check the history of the commits of our project using the git log command. 
Let's go back to our example scripts directory where we performed two commits and check out what git log has to say about those two commits. 

cd scripts
git log

Code output:
commit d8e139cc4f7dcd13b75cff67cfb68527e24c59c5 (HEAD -> master)
Author: My name <me@example.com>
Date:   Thu Jul 11 17:19:32 2019 +0200
    Add a check_reboot function
commit 6cfc29966acda8213fcd8ac2735b31f3fdbc6c53
Author: My name <me@example.com>
Date:   Thu Jul 11 12:08:46 2019 +0200
    Create and empty all_checks.py


Take a look at what git tracks as part of the log. It's packing a lot of information in just a few lines. 
The first thing listed for each commit is its identifier, which is a long string of letters and numbers that uniquely identify each commit. 
The first commit in the list also says that the head indicator is pointing to the master branch: commit d8e139cc4f7dcd13b75cff67cfb68527e24c59c 

For each commit, we see the name and the email of the person who made the commit which is indicated as the author.

Then we get the date and time the commit was made.

Finally the commit message is displayed.

Our commit messages are very brief as we're just starting to work on our repository. As the work we do becomes more complex, we'll probably write longer descriptions with a lot more detail.

Coming up, we've got a cheat sheet for you that lists all the git commands we've seen up until now along with links to additional information that you might find useful. 
After that, head over to the next practice quiz to help make sure you've wrapped your head around all these new concepts.


1.3.5. Git


In any Git project, there are three sections: the Git directory, the working tree, and the staging area. 

Git config command

The Git config command is used to set the values to identify who made changes to Git repositories. 
To set the values of user.email and user.name to your email and name, type: 

: ~$ git config  - -global user.email “me@example.com”
: ~$ git config  - -global user.name “My name”

git init command

: ~/checks$ git init

The Git init command can create a new empty repository in a current directory or re-initialize an existing one. 

git ls -la command

: ~/checks$ ls -la

The Git ls - la command checks that an identified directory exists.

: ~/checks$ ls -l .git/

The ls-l.git command checks inside the directory to see the different things that it contains. 
This is called the Git directory. 
The Git directory is a database for your Git project that stores the changes and the change history.

git add command

:~/checks$ git add disk_usage.py

Using the Git add command allows Git to track your file and uses the selected file as a parameter 
when adding it to the staging area. The staging area is a file maintained by Git 
that contains all the information about what files and changes are going to go into your next commit.

git status command

:~/checks$ git status

The Git status command is used to get some information about the current working tree and pending changes.

git commit command

:~/checks$ git commit

The .git commit command is run to remove changes made from the staging area to the .git directory. 
When this command is run, it tells Git to save changes. A text editor is opened that allows a commit message to be entered.

Guidelines for writing commit messages
A commit message is generally broken into two sections: a short summary and a description of the changes. 
When the git commit command is run, Git will open a text editor to write your commit message. 

A good commit message includes the following:
Summary: The first line contains the summary, formatted as a header, containing 50 characters or less. 
Description: The description is usually kept under 72 characters and provides detailed information about the change. 
It can include references to bugs or issues that will be fixed with the change. It also can include links to more information when relevant. 
Click the link to review an example of a commit message: 
https://commit.style/

Key takeaways
Knowing basic Git commands and guidelines for writing better messages can help you get started with Git as well as better communicate with others.


1.3.6. Quiz

Before changes in new files can be added to the Git directory, what command will tell Git to track our file in the list of changes to be committed?
git add
Right on! git add will add a file to the staging area and mark it for tracking.

Question 2
Which command would we use to review the commit history for our project?
git log
Awesome! git log will give us information about the author of each commit, its timestamp, and each commit message.

Question 3
What command would we use to make Git track our file?
git add
Great work! git add is used to make git mark our file as tracked.

Question 4
Which command would we use to look at our config?
git config -l
Great work! git config -l is used to check the current user configuration.

Question 5
Which command would we use to view pending changes?
git status
Woohoo! git status is used to retrieve information about changes waiting to be committed.

Glossary terms from course 3, module 1

Commit: A command to make edits to multiple files and treat that collection of edits as a single change
Commit files: A stage where the changes made to files are safely stored in a snapshot in the Git directory
Commit message: A summary and description with contextual information on the parts of the code or configuration of the commit change
Diff: A command to find the differences between two files
DNS zone file: A configuration file that specifies the mappings between IP addresses and host names in your network
Git: A free open source version control system available for installation on Unix based platforms, Windows and macOS
Git directory: A database for a Git project that stores the changes and the change history
Git log: A log that displays commit messages 
Git staging area: A file maintained by Git that contains all the information about what files and changes are going to go into the next commit
Modified files: A stage where changes have been made to a file, but the have not been stored or committed 
Patch: A command that can detect that there were changes made to the file and will do its best to apply the changes
Repository: An organization system of files that contain separate software projects 
Source Control Management (SCM): A tool similar to VCS to store source code
Stage files: A stage where the changes to files are ready to be committed 
Tracked: A file’s changes are recorded
Untracked: A file’s changes are not recorded
Version control systems (VCS): A tool to safely test code before releasing it, allow multiple people collaborate on the same coding projects together, and stores the history of that code and configuration


————————————————————————————————————————
git add
davidtbo@MacBook-Air-de-David 32_GitHub % git status
On branch main
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	deleted:    matrice.py

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   Fiche_Git.rtf

davidtbo@MacBook-Air-de-David 32_GitHub % git add Fiche_Git.rtf 
davidtbo@MacBook-Air-de-David 32_GitHub % git status
On branch main
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	modified:   Fiche_Git.rtf
	deleted:    matrice.py
————————————————————————————————————————

git add *
To stage all the files